/* Documentation
 *
 * This main routine test the sg_map component.
 */

//**** Library includes
#include <opencv/cv.h>
#include <opencv/cvaux.h>
#include <opencv/highgui.h>

#include <iostream>
#include <fstream>
#include "time.h"

#include "sg_map.h"
#include "define.h"

#define USAGE \
  "USAGE: maps2graph_test -f <map_filename>\n" \
  "       [-f <map_filename>] : name of the img file to process \n" \
  "       [-l <lower_threshold>] : \n" \
  "       [-d <dist_minimum>] : \n" \
  "       [-r <min_clearance>] : \n" \
  "       [-c <minima_inc_corridor>] : \n" \
  "       [-s <sense_range_pix>] : \n" \
  "       [-e <min_decreasing>] : "
//e.g. ./maps2graph_test -d 60 -r 10 -c 12 -e 1
// ./maps2graph_test -f maps/map10.bmp -d 0 -r 0 -c 3 -e 0.3
// ./maps2graph_test -f maps/ucm3.bmp -d 20 -r 8 -c 6 -e 0.4
// ./maps2graph_test -f maps/sdr_180t_2pxGB_180t.bmp -d 15 -r 3 -c 4 -e 0.2

// First best vertex is 32 cleared at cost 18
// Best vertex is 2 cleared at cost 14
// prev vertex number 65 now: 22"Printing graph to files and images"
// ./strategy_map_test -f maps/ucm3.bmp -d 20 -r 8 -c 4 -e 0.3
// -d 15 -r 3 -c 3 -e 0.3


/* andreas
 * 
 * Notes on the parameters:
 * 
 * Key parameter are the minima_inc_corridor and the min_creasing as they
 * define the stability of the maxima w.r.t to small perturbations.
 * In general one should set these rather high i.e. at least -c 3 -e
 * 0.3
 * 
 * Good values for -e are somewhere between 0.1 and 0.5 (very strongly
 * decreasing)
 * 
 * Good values for -c depend on the resolution of the map w.r.t to its
 * complexity (openness of corridors etc.)
 * 
 * -r the min_clearance can easily be related to the robot and target
 * size. Wherever a target cannot pass through we do not need to put
 * an edge.
 * 
 * -d dist_mini should ideally be 0, then we don\'t weed out voronoi_minima
 * artifically. Ideally close voronoi_minima get merged during the graph merging
 * process and those that don\'t should exist, e.g. opposite doors at
 * narrow corridors in an office building
 * 
 * Problem with DIAGONAL waves:
 * Since our heuristic considers a diagonal as an introduction of an new obstacle we have lots of voronoi lines in a roughly straight corridor that go to the wall of that corridor which prevents a voronoi_minima from being accepted as a closer minimum exists when going closer to the wall. Hence -c should not be set to high
 */

int main(int argc, char **argv) {

	//******* Setting the Options  *******
	char* map_img_filename = "/Users/andreas/robots/libraries/surveillance/graph_clear/bin/maps/ucm3.bmp";
	
	// These are just unimportant processing options
	int lower_thres = 3;
	
	//******* Essential parameters *******
	int sensing = 20;
	// Ideally this should be 0, i.e. voronoi_minima do not need an artificial spacing
	int dist_mini = sensing; 
	// This should be the minimum distance a robot/target needs to go through the space 
	// But on the other hand voronoi_minima that are within sensing range should not have to be 
	// considered
	int min_clearance = 2; 
	// The corridor defines the stability of the minimum. Ideally a minimum is steadily
	// decreasing in at least one direction
	int min_cor = 2 * min_clearance;
	float min_decreasing = 0.3;

	int i=1;
	while( i<argc ) {
		if( !strcmp( argv[i], "-f") ) {
			if( ++i < argc )
				map_img_filename = argv[i];
			else {
				puts(USAGE);
				exit(1);
			}
		}
		else if( !strcmp( argv[i], "-l" ) ) {
			if( ++i < argc )
				lower_thres = atoi(argv[3]);
			else {
				puts( USAGE );
				exit(1);
			}
		}
		else if( !strcmp( argv[i], "-d" ) ) {
			if( ++i < argc )
				dist_mini = atoi(argv[i]);
			else {
				puts( USAGE );
				exit(1);
			}
		}
		else if( !strcmp( argv[i], "-r" ) ) {
			if( ++i < argc )
				min_clearance = atoi(argv[i]);
			else {
				puts( USAGE );
				exit(1);
			}
		}
		else if( !strcmp( argv[i], "-c" ) ) {
			if( ++i < argc )
				min_cor = atoi(argv[i]);
			else {
				puts( USAGE );
				exit(1);
			}
		}
		else if( !strcmp( argv[i], "-e" ) ) {
			if( ++i < argc )
				min_decreasing = atof(argv[i]);
			else {
				puts( USAGE );
				exit(1);
			}
		}
		else if( !strcmp( argv[i], "-s" ) ) {
			if( ++i < argc )
				sensing = atoi(argv[i]);
			else {
				puts( USAGE );
				exit(1);
			}
		}
		else {
			puts( USAGE );
			exit(1);
		}
		i++;
	}

	cout << "Map  " << map_img_filename << endl;
	cout << "Picture threshold preprocessing with " << lower_thres << endl;
	cout << "Sensing range " << sensing << endl;
	cout << "Min distance between voronoi_minima " << dist_mini << endl;
	cout << "Min clearance for voronoi_minima " << min_clearance << endl;
	cout << "Corridor for voronoi_minima " << min_cor << endl;
	cout << "Descreasing within corridor by: " << min_decreasing << endl;

	// Suboptimal since we do the same in process_img; this is only needed to get the size
	IplImage* img_map = NULL;
	img_map = cvLoadImage( map_img_filename , -1);
	cvNamedWindow( "Original Map", CV_WINDOW_AUTOSIZE );
	cvShowImage( "Original Map", img_map);
	cvSaveImage( "output/map.bmp", img_map );

	//******* Starting Timing *******
	clock_t start = clock();

	//******* Main *******
	// Create the sg_map - height is nrows, width is ncols
	DEBUG_1("Creating sg_map");
	sg_map* the_map;
	the_map = new sg_map( img_map->height, img_map->width, dist_mini, min_clearance, min_cor, min_decreasing);
	cvReleaseImage(&img_map);
	the_map->process_img( map_img_filename , double(lower_thres) );
	the_map->set_sense_range_pix( sensing );
	DEBUG_1("Processing the sg_map");
	the_map->process_map();
	the_map->display_clearance_value();
	the_map->display_graph(0, 0, "output/graph.bmp", "output/graph2.bmp");
	the_map->get_graph()->print_graph_to_file("graph.gdl", 1, 1);
 
	//******* Finishing Timing *******
	clock_t finish = clock();
	cout << "==> " << (finish - start)/CLOCKS_PER_SEC << " seconds" << endl;
	cout << "Ctrl-c to finish" << endl;
	cvWaitKey(0);
	return 0;
}